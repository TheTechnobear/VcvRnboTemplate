#include "plugin.hpp"

// #define RNBO_NOSTL
// #define RNBO_USE_FLOAT32
#define RNBO_NOTHROW  // no exceptopns
// #define RNBO_USECUSTOMPLATFORM
#define RNBO_USECUSTOMPLATFORMPRINT
// #define RNBO_USECUSTOMALLOCATOR
#define RNBO_FIXEDLISTSIZE 64
#define RNBO_NO_PATCHERFACTORY


// a couple of user options

// use a generic title - disable by commenting out (with //)
// comment this out, and then have a custom panel with title on background
#define GENERIC_TITLE_LABEL


// use the generic UI - disable by commenting out (with //)
// to use your own UI you will need to : 
// - comment GENERIC_UI out 
// - create a panel file (res/__MOD__.svg), which has params and IO in same order as rnbo patch
// - run $RACK_DIR/helper.py createmodule __MOD__ res/__MOD__.svg tmp.cpp
// - from tmp.cpp copy enum ParamId, InputId, OutputId and place in this file after enum LightId
// - from tmp.cpp copy ___MOD__Widget and replace where indicated below (search CUSTOM WIDGET)
// to come: more information in documentation and possible yt video on my channel.
#define GENERIC_UI



namespace RNBO {
namespace Platform {
static void printMessage(const char* message) {
}
static void printErrorMessage(const char* message) {
}
}  // namespace Platform
}  // namespace RNBO


// ignore warnings generated by rnbo export, outside our control
#pragma GCC diagnostic push
// #ifndef __clang__
#pragma GCC diagnostic ignored "-Wsign-compare"
#pragma GCC diagnostic ignored "-Wswitch"
#pragma GCC diagnostic ignored "-Wunused-variable"

// mm compiler - warnings
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#pragma GCC diagnostic ignored "-Wunused-value"
// #endif
#include "__MOD__-rnbo/__MOD__.cpp.h"
#pragma GCC diagnostic pop

#ifdef GENERIC_UI
namespace __MOD___UI {
const float titleSpaceY = 20.f;
const float inputSpaceY = 20.f;
const float outputSpaceY = 20.f;

const float borderX = 17.f;
const float spaceY = 15.f;
const float spaceX = 15.f;
};  // namespace __MOD___UI
#endif

struct __MOD__ : Module {
    enum LightId { LIGHTS_LEN };
    //if you use a CUSTOM UI, this is where you need to add enum paramId, enum InputId, enum OutputId 

    __MOD__() {
        rnboInit();
        config(rnbo_.nParams_, rnbo_.nInputs_, rnbo_.nOutputs_, LIGHTS_LEN);
        for (int i = 0; i < rnbo_.nParams_; i++) {
            RNBO::ParameterInfo p_info;
            rnbo_.patch_.getParameterInfo(i, &p_info);
            auto displayName = p_info.displayName;
            // auto steps = p_info.steps;
            auto min = p_info.min;
            auto max = p_info.max;
            auto defaultVal = p_info.initialValue;
            configParam(i, min, max, defaultVal, displayName);
        }

        for (int i = 0; i < rnbo_.nInputs_; i++) {
            // no name in rnbo for inputs/outputs
            const std::string name = "";
            configInput(i, name);
        }
        for (int i = 0; i < rnbo_.nOutputs_; i++) {
            // no name in rnbo for inputs/outputs
            const std::string name = "";
            configOutput(i, name);
        }
    }

    ~__MOD__() override { rnboDeInit(); }


    void process(const ProcessArgs& args) override { doProcess(args); }

    void doProcess(const ProcessArgs& args);

    void rnboInit();
    void rnboDeInit();

    unsigned int curBufPos_ = 0;

    const unsigned int bufferSize_ = 1;
    unsigned int sampleRate_ = 48000;

    struct RNBOPatch {
        RNBO::__MOD__Rnbo<RNBO::MinimalEngine<>> patch_;
        int nInputs_ = 0;
        RNBO::number** inputBuffers_;
        int nOutputs_ = 0;
        RNBO::number** outputBuffers_;
        int nParams_ = 0;
        float* lastParamVals_;
    } rnbo_;

    RNBO::__MOD__Rnbo<RNBO::MinimalEngine<>>* getRnboPatch() { return &rnbo_.patch_; }

    void onSampleRateChange(const SampleRateChangeEvent& e) override {
        sampleRate_ = e.sampleRate;
        rnbo_.patch_.prepareToProcess(bufferSize_, sampleRate_, true);
    }
};

void __MOD__::rnboInit() {
    rnbo_.patch_.initialize();

    rnbo_.nInputs_ = rnbo_.patch_.getNumInputChannels();
    rnbo_.inputBuffers_ = new RNBO::number*[rnbo_.nInputs_];
    for (int i = 0; i < rnbo_.nInputs_; i++) { rnbo_.inputBuffers_[i] = new RNBO::number[bufferSize_]; }
    rnbo_.nOutputs_ = rnbo_.patch_.getNumOutputChannels();
    rnbo_.outputBuffers_ = new RNBO::number*[rnbo_.nOutputs_];
    for (int i = 0; i < rnbo_.nOutputs_; i++) { rnbo_.outputBuffers_[i] = new RNBO::number[bufferSize_]; }

    rnbo_.nParams_ = rnbo_.patch_.getNumParameters();
    rnbo_.lastParamVals_ = new float[rnbo_.nParams_];
    for (int i = 0; i < rnbo_.nParams_; i++) { rnbo_.lastParamVals_[i] = -1.0; }

    rnbo_.patch_.prepareToProcess(bufferSize_, sampleRate_, true);
}

void __MOD__::rnboDeInit() {
    for (int i = 0; i < rnbo_.nInputs_; i++) { delete rnbo_.inputBuffers_[i]; }
    delete rnbo_.inputBuffers_;
    for (int i = 0; i < rnbo_.nOutputs_; i++) { delete rnbo_.outputBuffers_[i]; }
    delete rnbo_.outputBuffers_;
    delete rnbo_.lastParamVals_;
}


#ifdef GENERIC_UI
using namespace __MOD___UI;
struct __MOD__Widget : ModuleWidget {
    __MOD__Widget(__MOD__* module) {
        /// a generic layout for modules
        // if you want a custom UI layout, you could replace this with a generated one from vcv sdk
        // you would need to ensure the parameter, input and output indexes matched RNBO

        setModule(module);
        setPanel(createPanel(asset::plugin(pluginInstance, "res/__PANEL__")));

        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        const float maxWidthInPx = box.size.x;
        const float maxWidth = (maxWidthInPx / mm2px(1.0)) - borderX;
#ifdef GENERIC_TITLE_LABEL
        addLabel(mm2px(Vec(borderX / 2.0f, 0)), "__MOD__", 18.f, maxWidth, nvgRGB(0xff, 0x00, 0x00));
#endif
        RNBO::__MOD__Rnbo<RNBO::MinimalEngine<>>* pPatch = nullptr;
        if (module) {
            pPatch = module->getRnboPatch();
        } else {
            // model == null  means preview, so we need to query patch directly
            pPatch = new RNBO::__MOD__Rnbo<RNBO::MinimalEngine<>>();
        }
        int nParams = pPatch->getNumParameters();
        int nInputs = pPatch->getNumInputChannels();
        int nOutputs = pPatch->getNumOutputChannels();

        float posX = borderX;
        float posY = titleSpaceY;
        RNBO::ParameterInfo p_info;
        for (int i = 0; i < nParams; i++) {
            if (posX >= maxWidth) {
                posY += spaceY;
                posX = borderX;
            }
            addParam(createParamCentered<RoundBlackKnob>(mm2px(Vec(posX, posY)), module, i));
            pPatch->getParameterInfo(i, &p_info);
            auto pname = p_info.displayName;
            addLabel(mm2px(Vec(posX - (spaceX / 2.f), posY + (spaceY / 4.f))), pname, 10.f, spaceX,
                     nvgRGB(0x00, 0x00, 0x00));
            posX += spaceX;
        }

        posX = borderX;
        posY += inputSpaceY;
        for (int i = 0; i < nInputs; i++) {
            if (posX >= maxWidth) {
                posY += spaceY;
                posX = borderX;
            }
            addInput(createInputCentered<PJ301MPort>(mm2px(Vec(posX, posY)), module, i));
            addLabel(mm2px(Vec(posX - (spaceX / 2.f), posY + (spaceY / 4.f))),
                     std::string("In") + std::to_string(i + 1), 10.f, spaceX, nvgRGB(0x00, 0x00, 0x00));
            posX += spaceX;
        }

        posX = borderX;
        posY += outputSpaceY;
        for (int i = 0; i < nOutputs; i++) {
            if (posX >= maxWidth) {
                posY += spaceY;
                posX = borderX;
            }
            addOutput(createOutputCentered<PJ301MPort>(mm2px(Vec(posX, posY)), module, i));
            addLabel(mm2px(Vec(posX - (spaceX / 2.f), posY + (spaceY / 4.f))),
                     std::string("Out") + std::to_string(i + 1), 10.f, spaceX, nvgRGB(0x00, 0x00, 0x00));
            posX += spaceX;
        }

        if (!module) { delete pPatch; }
    }

    void addLabel(const Vec& pos, const std::string& txt, float fontSize, float width, const NVGcolor& clr) {
        auto* label = new Label();
        label->box.pos = pos;
        label->box.size.x = mm2px(width * 2);
        label->box.size.y = fontSize;
        label->lineHeight = 1.0f;
        label->text = txt.c_str();
        label->color = clr;
        label->fontSize = fontSize;
        label->alignment = Label::LEFT_ALIGNMENT;
        addChild(label);
    }
};
#else 
// this is where you need to place the CUSTOM WIDGET
// see above, about generating and creating struct __MOD__Widget
#endif //  GENERIC_UI


Model* model__MOD__ = createModel<__MOD__, __MOD__Widget>("__MOD__");

void __MOD__::doProcess(const ProcessArgs& args) {
    bool rnboProcess = (curBufPos_ == bufferSize_ - 1);

    // process input
    for (int i = 0; i < rnbo_.nInputs_; i++) {
        float input = inputs[i].getVoltage();
        rnbo_.inputBuffers_[i][curBufPos_] = input;
    }

    if (rnboProcess) {
        // set parameters up for patch, only set on change

        for (int i = 0; i < rnbo_.nParams_; i++) {
            float param = params[i].getValue();
            if (rnbo_.lastParamVals_[i] != param) {
                rnbo_.patch_.setParameterValue(i, param, RNBO::TimeNow);
                rnbo_.lastParamVals_[i] = param;
            }
        }

        rnbo_.patch_.process(rnbo_.inputBuffers_, rnbo_.nInputs_, rnbo_.outputBuffers_, rnbo_.nOutputs_, bufferSize_);

    }  // rnbo process

    // send outputs
    for (int i = 0; i < rnbo_.nOutputs_; i++) { outputs[i].setVoltage(rnbo_.outputBuffers_[i][curBufPos_]); }

    curBufPos_++;
    if (curBufPos_ >= bufferSize_) curBufPos_ = 0;
}
